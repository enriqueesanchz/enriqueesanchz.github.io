[ { "title": "WorkoutAI - Identificación del ejercicio físico", "url": "/posts/WorkoutAI/", "categories": "AI", "tags": "ai, workout, fitness", "date": "2024-02-24 13:00:00 +0000", "snippet": "Soy una persona a la que le encanta el ejercicio físico, deporte, etc. y voy al gimnasio diariamente. En los inicios del entrenamiento físico consigues un gran cambio, progresas semana a semana y te sientes muy realizado, pero la cosa es diferente cuando pasas ese periodo, llevas más tiempo y te estancas.Empiezas a creer que no hay mejoras, que la forma de entrenar no es la correcta… Es aquí cuando llega la necesidad de controlar y apuntar el ejercicio que realizas. Peso Series Repeticiones RIR Fecha 100 3 10 0 23 noviembre 2023 105 3 6 0 30 noviembre 2023 100 3 6 1 13 diciembre 2023 105 3 8 0 20 diciembre 2023 Desde septiembre de 2023 llevo un control sobre el peso, número de repeticiones, series y RIR (repeticiones en reserva) de cada ejercicio de mi entrenamiento diario. Este control se vuelve repetitivo día tras día y, como buen ingeniero, odio las tareas innecesarias y repetitivas, buscando ante todo, automatizar.La ideaMi amigo y compañero del Máster, Manuel Jerez, y yo nos pusimos manos a la obra. Queríamos crear una app que automatice el apuntado de estas medidas.Para ello, hay que resolver una serie de problemas: Qué ejercicio se está realizando Qué peso se está levantando Número de series Número de repeticiones RIR (relacionado con el esfuerzo)En este artículo trataré el reconocimiento del ejercicio que se está realizando y el número de repeticiones.DatosPara conseguir el objetivo, necesitamos unos datos de entrada. Estos serán los proporcionados por un acelerómetro y giroscopio que el sujeto portará atado a la muñeca (como un reloj inteligente), en este caso, prototipado con una Raspberry Pi y un Sense Hat.De esta manera, los datos de entrada serán las aceleraciones y velocidades angulares en los 3 ejes.Toma de datosSe han tomado datos para 10 tipos de ejercicio diferentes, que han sido escogidos de manera que cada uno se parezca a algunos de los demás, para demostrar que es capaz de diferenciar entre patrones de movimiento similares. Concretamente: Press militar Press inclinado Press sentado Bíceps martillo Bíceps unilateral polea Tríceps polea Tríceps unilateral polea Remo bajo Jalón unilateral Jalón al pechoPrimera iteraciónEn un principio intentamos reconocer el tipo de ejercicio dividiendo los datos en trozos de 40 muestras, sin tener en cuenta si la repetición estaba empezando, finalizando, centrada, etc.A partir de estos datos en trozos, entrenamos varias redes neuronales, llegando algunas a ser bastante complejas. Los resultados no fueron buenos, se obtuvo un máximo de 65% de accuracy.Tras esto, nos centramos en realizar un buen preprocesado de datos para la segunda iteración.Segunda iteraciónPara esta iteración nos centramos más en tratar los datos de una manera más inteligente. Para ello realizamos una división de los datos en repeticiones.Número de repeticionesPara identificar el número de repeticiones realizadas vamos a utilizar un algoritmo determinista, basado en el cálculo de un umbral. Cuando los valores de aceleración/velocidad sean mayores que este umbral, identificamos una repetición.Para escoger el umbral de manera automática se ha realizado el siguiente proceso: Se calcula la desviación estándar de los datos en cada eje: El eje donde esta sea mayor, tendrá una mayor variación durante el ejercicio físico, por lo que será más fácil distinguir las repeticiones fijándonos en este eje. Calculamos el percentil 90 de los datos de dicho eje: De esta manera obtenemos un valor mayor que el 90% de los datos, asumiendo que el número de datos de pico de repetición será el 10% restante.Haciendo uso de este método y eliminando los datos que no consideramos repetición nos queda lo siguiente (zoom):Si colocamos una repetición sobre otra podemos ver el parecido que tienen todas según el tipo de ejercicio del que se trate.Identificación del ejercicioEstamos ante un problema de clasificación. Para resolverlo vamos a usar una Red Neuronal Convolucional 1D, con una capa densa y una capa final softmax:Se ha elegido este tipo de red porque: Es simple Ocupa pocos recursos, por lo que se podría usar incluso en sistemas empotrados: 87 KB, es decir, mucho menos que este post de mi blog o cualquier imagen de las que enlaza. Es suficiente para obtener buenos resultados (para el conjunto de 10 tipos de ejercicios)Se obtienen los siguientes resultados para los datos de test, fallando tan solo en 1 repetición entre dos ejercicios muy parecidos en cuanto a movimiento como son el press inclinado y el press militar.ConclusionesSe ha conseguido identificar los diferentes ejercicios con un 99% de accuracy en test. Esto no es lo más relevante, puesto que, existen factores no estudiados como qué pasaría con más de 10 clases de ejercicios, qué pasaría al introducir outliers, etc.La conclusión más importante que obtenemos es la importancia del dato. En la primera iteración, por mucho que añadiesemos complejidad a la red, no llegábamos a unos buenos resultados. Sin embargo, en la segunda iteración, tratando cuidadosamente los datos, se consigue una accuracy muy elevada, incluso con redes mucho más simples que las anteriormente evaluadas.Leer másEn un futuro escribiré sobre el resto de problemas a resolver de la aplicación, enlazándolos abajo: Identificación del RIR Número de series PesoTanto los datos como el código (Jupyter Notebooks) están disponibles en mi Repositorio de Github." }, { "title": "Nat traversal", "url": "/posts/Nat-traversal/", "categories": "Nat, Traversal", "tags": "nat, traversal, udp, hole punching", "date": "2023-10-13 18:00:00 +0000", "snippet": "Hace unas semanas mi ISP activó CG NAT (Carrier Grade Network Address Translation). Esto hizo que mis servidores dejasen de estar expuestos a internet con las reglas de port-forwarding que tenía configuradas.Lejos de llamar a la operadora y pedir que la desactiven, decidí intentar saltármela. Si las apps P2P funcionan detrás de esta NAT por qué no iba a poder yo usar estas técnicas para mis servicios.Así pues, me informé de como hacer NAT Traversal, UDP Hole Punching, STUN, TURN, ICE, etc. Además de servicios de “VPN p2p” como Tailscale, Zerotier… Estos resolvían mi problema, creando una red mesh entre mis dispositivos, y es lo que estuve usando.Como me encantan los retos, me propuse implementar una solución yo mismo, a partir de los conocimientos adquiridos en las técnicas mencionadas.UDP Hole PunchingEl “UDP Hole Punching” es una técnica usada para establecer una conexión directa entre dos dispositivos que están detrás de un firewall / NAT.Nos aprovechamos de que los firewalls generalmente permiten las conexiones salientes, por lo que para atravesarlos iniciaremos la conexión en los dos dispositivos a la vez, haciendo creer al firewall que ambas partes están iniciando el intercambio de mensajes. Primero, el lado A inicia la conexión con un paquete UDP con destino B. Este es rechazado puesto que el firewall B no ha visto ningún paquete saliente con dirección A. Segundo, el lado B inicia la conexión con un paquete UDP con destino A. Este sí llega correctamente puesto que A ha visto un paquete saliente con dirección B. Finalmente, obtenemos una comunicación bidireccional.Hay varios puntos que hemos pasado por alto. ¿cómo sabe cada dispositivo cuál es la dirección y puerto del otro para así poder iniciar la conexión? Para ello tendremos un servidor de señalización, como el expuesto en el apartado servidor de señalización. ¿estas direcciones ip:puerto cuáles son? Ya que sabemos que la NAT las modifica. Para solucionar este problema hacemos uso de STUN, un protocolo que permite preguntar a un servidor público cuál es mi ip:puerto desde su punto de vista.Tipos de NATPara el Hole Punching distinguimos dos tipos de NAT: Endpoint Independent NAT (EIM): para una misma pareja de origen ip:puerto la traducción no depende del destino. Es decir, podemos preguntar al servidor STUN cuál es nuestra ip:puerto y ésta será la misma que vean nuestros peers. Endpoint Dependent NAT (EDM): para una misma pareja de origen ip:puerto, la traducción varía según el destino escogido, por lo que al preguntar al servidor STUN cuál es nuestra ip:puerto no coincidirá con lo que vean nuestros peers. Para identificar si nuestra NAT es de este tipo, preguntamos a varios servidores STUN desde el mismo socket, si las respuestas muestran diferente ip:puerto estamos en este caso.CasosSegún el tipo de NAT de cada parte, distinguimos 3 casos.1. EIM-EIMSi los dos dispositivos están en el caso EIM, no hay ningún problema, se registran en el servidor de señalización y podrán establecer la conexión puesto que las parejas ip:puerto son conocidas.2. EIM-EDMSi uno de los dos dispositivos están el el caso EDM, tendremos que tratarlo de una manera especial, ya que conocemos una pareja ip:puerto pero la otra va cambiando según el destino (el servidor STUN no nos puede ayudar). Haremos uso de la paradoja del cumpleaños.Suponiendo que la ip que nos devuelve STUN en el lado EDM es correcta (REQ-2 RFC 4787), lo que no conocemos es el puerto. Este será 1 entre 65.535. Si podemos probar 100 puertos/segundo, en el peor caso serán 10 minutos escaneando puertos. Pero podemos hacerlo mejor, si en vez de abrir 1 puerto entre 65.535 en el lado EDM, abrimos 256 el número de peticiones aleatorias hasta encontrar una colisión se reduce mucho.Las mates de esto se explican en la paradoja del cumpleaños y pueden ser comprobadas con esta calculadora en python. Número de pruebas Probabilidad de éxito 174 50% 256 64% 1024 98% 2048 99.9% Si podemos probar 100 puertos/segundo, en el peor de los casos tardaremos 20 segundos en encontrar una colisión.3. EDM-EDMPodríamos aplicar el mismo truco que en el apartado anterior pero esta vez el espacio de búsqueda de colisión es mucho mayor por lo que con un escaneo de 100 puertos/segundo tardaríamos 28 minutos en encontrar una colisión con un 99.9% de posibilidades. El problema reside en que los routers tienen una memoria finita, por ejemplo el Juniper SRX 300 puede almacenar un máximo de 64.000 sesiones activas. Habríamos consumido todas estas solo para iniciar una conexión, lo cual sería un completo desastre.Debemos abandonar esta idea de probar y obtener la colisión por fuerza bruta. Si queremos establecer una conexión EDM-EDM podemos explorar técnicas más sofisticadas como analizar el patrón que sigue la NAT para intentar adivinar qué traducción de dirección va a realizar y así conseguir la colisión.Generalmente, el no poder establecer una conexión EDM-EDM no es un problema porque las NAT de los routers de casa suelen ser EIM y quizás los de empresa sean EDM, por lo que los escenarios home-to-home, home-to-office y home-to-cloud están a salvo.Negociar varias NATs¿Qué pasa si estás tras varias NATs? Este es mi caso puesto que estoy tras CG-NAT.Realmente, da igual, cada capa de NAT hará su propia traducción y todo funcionará correctamente.ImplementaciónTodo esto lo he implementado en una librería de Python llamada PyHolePuncher, para que a partir de ella se puedan establecer túneles UDP entre dos dispositivos que estén tras una NAT.En el apartado ejemplos encontramos cómo utilizar la librería para crear un chat P2P. Primero se crea un usuario y se registra en el servidor de señalización, en este caso en Rendezvous. Cuando ambos peers estén registrados pueden unirse mediante un “Chat room”. Con la opción “Chat to a peer” se crea el túnel UDP entre los dispositivos que permite intercambiar mensajes.Actualmente soporta los siguientes casos: EIM-EIM EIM-EDM EDM-EDMServidor de señalizaciónPara este proyecto he creado un servidor de señalización de ejemplo, donde los peers pueden unirse a salas y compartir la información necesaria para establecer la conexión directa.Rendezvous se trata de un servicio REST simple, cuyos métodos están explicados en la documentación de Swagger que provee. Una vez los distintos peers estén registrados e intercambien la información, podemos pasar al UDP Hole Punching.Leer másPara escribir este post me he inspirado en el blog de Tailscale, muy recomendado pues describe con precisión el fundamento tecnológico tras su producto, algo que sirve para aprender mucho sobre el tema. Si se quiere seguir profundizando: How NAT Traversal works How Tailscale works" }, { "title": "Arithmetic Coding - Optimización del algoritmo", "url": "/posts/Arithmetic-Coding-optimization/", "categories": "Algorithm, Coding", "tags": "coding, arithmetic, optimizar, algorithm", "date": "2023-09-14 14:00:00 +0000", "snippet": "Este post es la continuación de Arithmetic Coding - Qué es y primera implementación, que te recomiendo que leas antes de este.Bueno, al lío. Nos encontramos con un algoritmo que no es viable de ejecutar puesto que conforme vamos codificando símbolos, los números que usamos se van haciendo cada vez más largos (en bits).Para solucinar esto nos vamos a aprovechar de una propiedad de estos números, y es que si nos fijamos en la imagen, en el juego de partir en porciones y quedarnos con una, el extremo inferior del intervalo que vamos manteniendo (en verde) o crece o se queda igual, nunca decrece. Lo mismo pasa con el extremo superior, siempre decrece o queda igual, nunca crece.Traducción a bits¿Cómo afecta esto a las variables que usamos en la implementación? Primero tenemos que saber cómo vamos a representar estos números. Hay dos posibilidades: Punto flotante: se compone de una mantisa (bits de precisión) y un exponente. Esto te permite representar números muy pequeños o muy grandes con unos pocos dígitos de precisión. En nuestro caso el extremo superior e inferior van a ser cada vez más cercanos por lo que la distancia entre estos no se podrá representar usando la precisión que permite el punto flotante. Punto fijo: establecemos una convención del número de bits que usamos para la parte entera y decimal. En nuestro caso como los números estarán dentro de [0,1) tan solo necesitamos parte decimal. Vamos a usar una variable unsigned y la tratamos según esta convención.Implementación ingenuaUna vez sabemos como representar estos números, elegimos la longitud en bits que tendrán y ejecutamos el algoritmo. Aquí es cuando aparece el problema anteriormente planteado, conforme vamos codificando símbolos necesitamos más bits = más tiempo de cálculo en la próxima operación matemática.Implementación optimizada El extremo inferior siempre crece El extremo superior siempre decreceSi lo vemos en binario sería tal que así: El 0.25 representado con 4 bits es (0100). Si este es nuestro extremo inferior, solo va a crecer, por lo que si llega a 0.5 (1000), el primer bit pasará a ser 1, y así será siempre. Por lo tanto podremos descartarlo y llevar la cuenta de bits descartados. Con el extremo inferior pasa lo mismo, una vez el primer bit pasa a ser 0 siempre lo será.Además, sabemos que el extremo superior siempre va a ser mayor que el inferior, por lo que una vez que el primer bit del inferior llega a 1 el del superior también queda fijado. De la misma manera ocurre en el otro sentido. Esto permite ir descartando bits según vamos pudiendo para así realizar operaciones matemáticas con números infinitamente largos pero solo usando unos pocos de sus bits. Estos bits serán los que iremos emitiendo ya que forman el número que representa el mensaje codificado.Mola ¿eh?, esto es lo que hace que hoy en día se pueda usar este tipo de algoritmos ya que acelera muchísimo el procesado.Otras optimizaciones Árbol binario indexado:Por la naturaleza del algoritmo, vamos a realizar muchas consultas al vector de probabilidades que nos facilita el modelo. Siempre necesitamos la probabilidad de símbolo y dónde se encuentra dentro de las porciones del rango (representadas arriba en verde). A parte, debemos poder actualizar el modelo. Por ello, en lugar de almacenar estas probabilidades en un array lo haremos en un Árbol binario indexado, que nos permite realizar estas operaciones en O(log n).Otros problemas Pérdida de precisión:Puede darse que perdamos precisión cuando el extremo inferior se acerca a 0.5 por abajo y el extremo superior lo hace por arriba.De esta manera las variables en hexadecimal serían así: low high 7C99418B 81A60145 7FF8F3E1 8003DFFA 7FFFFC6F 80000DF4 7FFFFFF6 80000001 7FFFFFFF 80000000 Nunca llegamos al 1 inicial en low ni al 0 inicial en high. Para solucionar esto descartaremos el segundo bit más significativo (lo apuntamos en la cuenta de bits descartados) teniendo en cuenta que en algún momento se cumplirá la condición de 0.5. Cuando esto suceda, emitimos el bit correspondiente y los siguientes serán el contrario (tantos como apuntamos en la cuenta).RustEn mi repositorio de github se encuentra la implementación en Rust de este algoritmo. El ejemplo comprime “El Quijote” usando un modelo simple de frecuencias planas para cada símbolo, consiguiendo así pasar de 2.1 MB a 1.1 MB en 0.7 segundos, mientras que con la implementación ingenua esto podría tardar incluso años.Un mayor ratio de compresión se puede lograr si usamos modelos como PPM o cadenas de Markov, los cuales dan para otro post.Detalles Número de símbolos arbitrario: el ejemplo usa 256 para codificar un archivo leido en bytes Modelo de probabilidades plano Uso de variables unsigned32: operaciones con 32 bits Lenguaje compilado para una mayor velocidadLeer másEste artículo pretende ser conciso y ameno, por lo que hay detalles que pueden quedar en el aire. Para obtener más información sobre el tema recomiendo el artículo de Mark Nelson Data Compression With Arithmetic Coding en el que me he inspirado para hacer este post.Personalmente, esto ha sido un reto que me propuse tras finalizar el trabajo incial. He aprendido a tener en cuenta qué coste de cómputo tienen las operaciones, manejo a nivel de bit, maneras diferentes de hacer lo mismo, abstraerme para lograr entender un algoritmo complejo y, de paso, programar en Rust." }, { "title": "Arithmetic Coding - Qué es y primera implementación", "url": "/posts/Arithmetic-Coding/", "categories": "Algorithm, Coding", "tags": "coding, arithmetic, algorithm", "date": "2023-09-11 17:30:00 +0000", "snippet": "El pasado curso hice un trabajo sobre la codificación aritmética y sus ventajas frente a otros tipos de codificación, aportando un código escrito en Python que mostraba su uso.Antes de nada,¿Qué es la Codificación Aritmética?La codificación aritmética es un método de compresión sin pérdidas que asigna códigos de longitud variable a los símbolos en función de sus probabilidades de ocurrencia. Los símbolos más probables tendrán códigos cortos, mientras que los símbolos menos probables se codifican con códigos más largos. A diferencia de otras codificaciones, podremos asignar códigos de longitud no entera para los símbolos, eliminando de esta manera dicha fuente de ineficiencia que tiene, por ejemplo, Huffman.Con esta técnica codificamos los datos en un solo número que estará entre el 0 y el 1.Ventajas Puede asignar una longitud de código no entera a los símbolos Adecuado para modelos adaptativosLimitaciones Hay que tener la palabra de bits completa para empezar la decodificación Si hay un bit corrupto en la palabra puede cambiar mucho el mensajeEjemploVamos a codificar/decodificar la secuencia B A C A.Codificar Lo primero que tenemos que hacer es crear una tabla (Modelo) con los símbolos que vamos a usar y sus probabilidades. En este caso tenemos 3 símbolos: Símbolo Probabilidad Rango B 0.25 [0, 0.25) A 0.5 [0.25, 0.75) C 0.25 [0.75, 1) Dividimos el intervalo [0, 1) según las probabilidades de ocurrencia. Como el primer símbolo es la B, nos quedamos con el intervalo [0, 0.25). Volvemos al paso 2, pero esta vez dividimos el intervalo disponible en lugar del [0, 1).De esta manera, repitiendo para cada símbolo codificamos la secuencia B A C A. En los intervalos mostrados se encuentran todas las secuencias con el mismo prefijo. Debemos poner un símbolo de fin o indicar la longitud total del mensaje para saber cuando parar de decodificar.El pseudocódigo queda así: Low = 0 High = 1 Bucle. Para cada símbolo. Rango = high - low High = low + rango * high_range del símbolo Low = low + rango * low_range del símbolo DecodificarEl proceso para decodificar es el mismo, gráficamente podemos ver que si nos llega el número 0.1640625 podremos identificar que pertenece al rango [0, 0.25), luego a [0.0625, 0.1875), y así hasta llegar al símbolo EOF o longitud requerida.ModeloPara codificar/decodificar necesitamos un modelo. Cuanto mejor represente a los datos más nos estaremos acercando al límite de compresión enunciado en el Primer Teorema de Shannon en 1934.Existen infinidad de modelos que representen la probabilidad de símbolo: Modelo simple: tabla de frecuencias estática como la usada en el ejemplo anterior Modelo adaptativo: tabla de frecuencias que varía. Iniciamos con frecuencias equiprobables y las vamos variando según van apareciendo los símbolos Modelo PPM: la frecuencia de los símbolos depende de los K símbolos anteriores Modelo de aprendizaje automático etcéteraPrimera implementaciónPara el trabajo de clase implementé una versión básica (e ineficiente) del algoritmo, pero que demostraba todo lo anterior. Teniendo en cuenta que usar variables de punto flotante nos limitaría los cálculos al tamaño de la mantisa, usé una librería de Python llamada “decimal”, que permite usar aritmética de punto fijo con el número de bits que queramos.El problema de esto reside en que cada vez que actualizamos el número que representa el mensaje a codificar, necesitamos más bits. Más bits = más tiempo de computación en la siguiente operación matemática. Por lo tanto, conforme aumentamos la longitud del mensaje el tiempo de procesamiento aumenta exponencialmente.Solución¿Cómo solucioné esto? Pues eso es tema para el próximo post. Arithmetic Coding - Optimización del algoritmo" }, { "title": "Cómo conseguí 400 usuarios para esta Web de F1", "url": "/posts/Como-consegui-400-usuarios/", "categories": "Web, F1", "tags": "web, f1, twitter, viral", "date": "2023-02-22 16:30:00 +0000", "snippet": "Esta es la historia de cómo llegamos a tener una web de Fórmula 1 con más de 400 usuarios hecha en tan solo 7 días.El comienzoDurante el auge del fenómeno EL PLAN en Twitter, allá por Febrero de 2022, @manueljerez7_ y yo tuvimos la idea de crear una web a modo de porra para un conjunto reducido de amigos.Aprovechamos que él tenía un grupo con otros usuarios de Twitter F1 que se reunían usando la herramienta Twitter Spaces para comentarles la idea. Les encantó, por lo que decidimos poner un Tweet para ver si a más gente le gustaba. Se viralizó.CHAVALES este año se viene a TwF1 un super UPGRADE:UNA WEB SENCILLA para hacer LA PORRA DE LA CARRERATe registras con tu usuario de Twitter, metes resultados y ves la clasificación general de puntosPronto os diré más 👀👀👀Se agradece difusión para llegar a más gente 🙏&amp;mdash; Manu 😉 (@manueljerez7_) February 11, 2022700 Likes, 130 RT, 90.000 Visualizaciones… Fue una idea muy bien recibida por la comunidad, así que nos pusimos manos a la obra ya que quedaban a penas 2 semanas para el comienzo de temporada y tenía que estar todo listo, funcionando y probado para el primer Gran Premio.Cómo nos organizamosAmbos estábamos cursando el grado de Ingeniería Telecomunicaciones en la Universidad de Sevilla, por lo que teníamos que organizar el poco tiempo sobrante que teníamos para llevar a cabo este proyecto. gantt dateFormat YYYY-MM-DD axisFormat %d title La Porra de Twitter F1 section Reglas Lluvia de ideas :a, 2022-02-09, 2d Formalización :b, after a, 2d section Investigación BBDD :c, 2022-02-09, 2d Despliegue :e, 2022-02-10, 2d section Implementación Diseño :f, 2022-02-10, 2d Inicio de sesión :d, after f, 2d Juego :g, after f, 3d section Optimización BBDD: h, 2022-02-15, 3d Servidor: i, 2022-02-15, 3dIdeas claveDe la fase de lluvia de ideas sacamos varias claves:- Inicio de sesión usando API TwitterEs muy importante eliminar las barreras de entrada que pueda tener un usuario. Puesto que nuestra publicidad era Twitter, el registro en nuestra web se hará mediante su API. El usuario únicamente tendrá que dar acceso a su nombre de cuenta en Twitter y su @ será su usuario en la web.Desde mi punto de vista, esto fue un completo acierto ya que el pulsar un botón de inicio de sesión con Twitter hace que el registro se vuelva automático y nada pesado.- Botón compartir en Twitter estilo WordleWordle se había viralizado ya que la gente podía hacer el reto diario y compartir su famoso código de colores en Twitter, por lo que nosotros inventamos el nuestro propio.Esto nos ayuda a llegar a un mayor público. Entrando en el hastag #LaPorraDeTwF1 se pueden comprobar los Tweets de los usuarios.Mis resultados de #LaPorraDeTwF1 para Bahrain🟩 🟥🟨 🟨🟥 🟥🟥 🟥🟥 🟥&amp;mdash; Enrique Sánchez (@enriqueesanchz) March 20, 2022- ReglasLas reglas se debatieron durante los primeros días para su posterior formalización. Básicamente consiste en colocar a los pilotos que creas que van a quedar los 10 primeros y según los resultados se te asigna una puntuación dependiendo de lo cerca que hayas estado de acertar.InvestigaciónEsta era una parte importante para decidir qué servicios íbamos a usar tanto para la Base de Datos como para dónde desplegar la Web, siempre intentando minimizar costes, ya que éramos estudiantes sin fuente de ingresos.- BBDDPara la Base de Datos teníamos las posibilidades de Google Cloud SQL, Firebase, Azure SQL, AWS SQL Server, etc. Terminamos decantándonos por Azure ya que por $5 teníamos 2Gb de almacenamiento, costeándolo durante la temporada de Fórmula 1 con el plan para estudiantes.- ServidorOtra parte vital es dónde desplegar la Web. Entre las diferentes opciones estaban de nuevo las plataformas de Google, Azure, AWS, etc. Al final elegimos Heroku con su plan gratuito ya que teníamos experiencia previa, Python y Flask. Cabe recalcar que teníamos algo de miedo por la viralización del Tweet y porque el número de usuarios que podríamos tener quizás hacía que la web cayese.ImplementaciónEn esta parte ideamos cómo iban a ser los diferentes componentes de nuestra arquitectura, sus relaciones y dependencias, etc.Comprende desde la implementación del inicio de sesión con Twitter para la web hasta la implementación del las reglas de la Porra en la Aplicación Web.OptimizaciónDurante estos días, estuve investigando sobre cómo optimizar al máximo nuestra web, en qué partes podíamos usar caché y en cuáles no, y otras optimizaciones de cara al servidor Web a usar, el número de hilos, etc. Estábamos preocupados por la viralización en Twitter.ConclusiónSe trata de una App Web sencilla, simple, hecha en tiempo récord, que cumple su función: Tener una porra a golpe de click desde Twitter, ideada para la comunidad de Twitter Fórmula 1.Terminamos teniendo más de 400 usuarios, muy contentos, aunque sabemos que podrían haber sido más. Esto se debe a que la dificultad de conseguir un Tweet viral creció para cuando se iba a iniciar la temporada de F1 por lo que aunque con el Tweet del primer anuncio llegásemos a 90 mil visualizaciones, los que pusimos en las vísperas del primer Gran Premio obtuvieron muchas menos debido a la cantidad de información y tweets que hubo en aquella época.Personalmente, considero todo un éxito este proyecto, en el cual he aprendido mucho con un ejemplo del mundo real y creo que la clave ha estado en centrarnos en la comodidad del usuario y la compartición en Twitter de los resultados con el código de colores.Leer más Análisis de datos de usuarios La Porra de Twitter F1 Diario de Manuel con el proyecto" } ]
