[ { "title": "WorkoutAI - Identificaci√≥n del ejercicio f√≠sico", "url": "/posts/WorkoutAI/", "categories": "AI", "tags": "ai, workout, fitness", "date": "2024-02-24 13:00:00 +0000", "snippet": "Soy una persona a la que le encanta el ejercicio f√≠sico, deporte, etc. y voy al gimnasio diariamente. En los inicios del entrenamiento f√≠sico consigues un gran cambio, progresas semana a semana y te sientes muy realizado, pero la cosa es diferente cuando pasas ese periodo, llevas m√°s tiempo y te estancas.Empiezas a creer que no hay mejoras, que la forma de entrenar no es la correcta‚Ä¶ Es aqu√≠ cuando llega la necesidad de controlar y apuntar el ejercicio que realizas. Peso Series Repeticiones RIR Fecha 100 3 10 0 23 noviembre 2023 105 3 6 0 30 noviembre 2023 100 3 6 1 13 diciembre 2023 105 3 8 0 20 diciembre 2023 Desde septiembre de 2023 llevo un control sobre el peso, n√∫mero de repeticiones, series y RIR (repeticiones en reserva) de cada ejercicio de mi entrenamiento diario. Este control se vuelve repetitivo d√≠a tras d√≠a y, como buen ingeniero, odio las tareas innecesarias y repetitivas, buscando ante todo, automatizar.La ideaMi amigo y compa√±ero del M√°ster, Manuel Jerez, y yo nos pusimos manos a la obra. Quer√≠amos crear una app que automatice el apuntado de estas medidas.Para ello, hay que resolver una serie de problemas: Qu√© ejercicio se est√° realizando Qu√© peso se est√° levantando N√∫mero de series N√∫mero de repeticiones RIR (relacionado con el esfuerzo)En este art√≠culo tratar√© el reconocimiento del ejercicio que se est√° realizando y el n√∫mero de repeticiones.DatosPara conseguir el objetivo, necesitamos unos datos de entrada. Estos ser√°n los proporcionados por un aceler√≥metro y giroscopio que el sujeto portar√° atado a la mu√±eca (como un reloj inteligente), en este caso, prototipado con una Raspberry Pi y un Sense Hat.De esta manera, los datos de entrada ser√°n las aceleraciones y velocidades angulares en los 3 ejes.Toma de datosSe han tomado datos para 10 tipos de ejercicio diferentes, que han sido escogidos de manera que cada uno se parezca a algunos de los dem√°s, para demostrar que es capaz de diferenciar entre patrones de movimiento similares. Concretamente: Press militar Press inclinado Press sentado B√≠ceps martillo B√≠ceps unilateral polea Tr√≠ceps polea Tr√≠ceps unilateral polea Remo bajo Jal√≥n unilateral Jal√≥n al pechoPrimera iteraci√≥nEn un principio intentamos reconocer el tipo de ejercicio dividiendo los datos en trozos de 40 muestras, sin tener en cuenta si la repetici√≥n estaba empezando, finalizando, centrada, etc.A partir de estos datos en trozos, entrenamos varias redes neuronales, llegando algunas a ser bastante complejas. Los resultados no fueron buenos, se obtuvo un m√°ximo de 65% de accuracy.Tras esto, nos centramos en realizar un buen preprocesado de datos para la segunda iteraci√≥n.Segunda iteraci√≥nPara esta iteraci√≥n nos centramos m√°s en tratar los datos de una manera m√°s inteligente. Para ello realizamos una divisi√≥n de los datos en repeticiones.N√∫mero de repeticionesPara identificar el n√∫mero de repeticiones realizadas vamos a utilizar un algoritmo determinista, basado en el c√°lculo de un umbral. Cuando los valores de aceleraci√≥n/velocidad sean mayores que este umbral, identificamos una repetici√≥n.Para escoger el umbral de manera autom√°tica se ha realizado el siguiente proceso: Se calcula la desviaci√≥n est√°ndar de los datos en cada eje: El eje donde esta sea mayor, tendr√° una mayor variaci√≥n durante el ejercicio f√≠sico, por lo que ser√° m√°s f√°cil distinguir las repeticiones fij√°ndonos en este eje. Calculamos el percentil 90 de los datos de dicho eje: De esta manera obtenemos un valor mayor que el 90% de los datos, asumiendo que el n√∫mero de datos de pico de repetici√≥n ser√° el 10% restante.Haciendo uso de este m√©todo y eliminando los datos que no consideramos repetici√≥n nos queda lo siguiente (zoom):Si colocamos una repetici√≥n sobre otra podemos ver el parecido que tienen todas seg√∫n el tipo de ejercicio del que se trate.Identificaci√≥n del ejercicioEstamos ante un problema de clasificaci√≥n. Para resolverlo vamos a usar una Red Neuronal Convolucional 1D, con una capa densa y una capa final softmax:Se ha elegido este tipo de red porque: Es simple Ocupa pocos recursos, por lo que se podr√≠a usar incluso en sistemas empotrados: 87 KB, es decir, mucho menos que este post de mi blog o cualquier imagen de las que enlaza. Es suficiente para obtener buenos resultados (para el conjunto de 10 tipos de ejercicios)Se obtienen los siguientes resultados para los datos de test, fallando tan solo en 1 repetici√≥n entre dos ejercicios muy parecidos en cuanto a movimiento como son el press inclinado y el press militar.ConclusionesSe ha conseguido identificar los diferentes ejercicios con un 99% de accuracy en test. Esto no es lo m√°s relevante, puesto que, existen factores no estudiados como qu√© pasar√≠a con m√°s de 10 clases de ejercicios, qu√© pasar√≠a al introducir outliers, etc.La conclusi√≥n m√°s importante que obtenemos es la importancia del dato. En la primera iteraci√≥n, por mucho que a√±adiesemos complejidad a la red, no lleg√°bamos a unos buenos resultados. Sin embargo, en la segunda iteraci√≥n, tratando cuidadosamente los datos, se consigue una accuracy muy elevada, incluso con redes mucho m√°s simples que las anteriormente evaluadas.Leer m√°sEn un futuro escribir√© sobre el resto de problemas a resolver de la aplicaci√≥n, enlaz√°ndolos abajo: Identificaci√≥n del RIR N√∫mero de series PesoTanto los datos como el c√≥digo (Jupyter Notebooks) est√°n disponibles en mi Repositorio de Github." }, { "title": "Nat traversal", "url": "/posts/Nat-traversal/", "categories": "Nat, Traversal", "tags": "nat, traversal, udp, hole punching", "date": "2023-10-13 18:00:00 +0000", "snippet": "Hace unas semanas mi ISP activ√≥ CG NAT (Carrier Grade Network Address Translation). Esto hizo que mis servidores dejasen de estar expuestos a internet con las reglas de port-forwarding que ten√≠a configuradas.Lejos de llamar a la operadora y pedir que la desactiven, decid√≠ intentar salt√°rmela. Si las apps P2P funcionan detr√°s de esta NAT por qu√© no iba a poder yo usar estas t√©cnicas para mis servicios.As√≠ pues, me inform√© de como hacer NAT Traversal, UDP Hole Punching, STUN, TURN, ICE, etc. Adem√°s de servicios de ‚ÄúVPN p2p‚Äù como Tailscale, Zerotier‚Ä¶ Estos resolv√≠an mi problema, creando una red mesh entre mis dispositivos, y es lo que estuve usando.Como me encantan los retos, me propuse implementar una soluci√≥n yo mismo, a partir de los conocimientos adquiridos en las t√©cnicas mencionadas.UDP Hole PunchingEl ‚ÄúUDP Hole Punching‚Äù es una t√©cnica usada para establecer una conexi√≥n directa entre dos dispositivos que est√°n detr√°s de un firewall / NAT.Nos aprovechamos de que los firewalls generalmente permiten las conexiones salientes, por lo que para atravesarlos iniciaremos la conexi√≥n en los dos dispositivos a la vez, haciendo creer al firewall que ambas partes est√°n iniciando el intercambio de mensajes. Primero, el lado A inicia la conexi√≥n con un paquete UDP con destino B. Este es rechazado puesto que el firewall B no ha visto ning√∫n paquete saliente con direcci√≥n A. Segundo, el lado B inicia la conexi√≥n con un paquete UDP con destino A. Este s√≠ llega correctamente puesto que A ha visto un paquete saliente con direcci√≥n B. Finalmente, obtenemos una comunicaci√≥n bidireccional.Hay varios puntos que hemos pasado por alto. ¬øc√≥mo sabe cada dispositivo cu√°l es la direcci√≥n y puerto del otro para as√≠ poder iniciar la conexi√≥n? Para ello tendremos un servidor de se√±alizaci√≥n, como el expuesto en el apartado servidor de se√±alizaci√≥n. ¬øestas direcciones ip:puerto cu√°les son? Ya que sabemos que la NAT las modifica. Para solucionar este problema hacemos uso de STUN, un protocolo que permite preguntar a un servidor p√∫blico cu√°l es mi ip:puerto desde su punto de vista.Tipos de NATPara el Hole Punching distinguimos dos tipos de NAT: Endpoint Independent NAT (EIM): para una misma pareja de origen ip:puerto la traducci√≥n no depende del destino. Es decir, podemos preguntar al servidor STUN cu√°l es nuestra ip:puerto y √©sta ser√° la misma que vean nuestros peers. Endpoint Dependent NAT (EDM): para una misma pareja de origen ip:puerto, la traducci√≥n var√≠a seg√∫n el destino escogido, por lo que al preguntar al servidor STUN cu√°l es nuestra ip:puerto no coincidir√° con lo que vean nuestros peers. Para identificar si nuestra NAT es de este tipo, preguntamos a varios servidores STUN desde el mismo socket, si las respuestas muestran diferente ip:puerto estamos en este caso.CasosSeg√∫n el tipo de NAT de cada parte, distinguimos 3 casos.1. EIM-EIMSi los dos dispositivos est√°n en el caso EIM, no hay ning√∫n problema, se registran en el servidor de se√±alizaci√≥n y podr√°n establecer la conexi√≥n puesto que las parejas ip:puerto son conocidas.2. EIM-EDMSi uno de los dos dispositivos est√°n el el caso EDM, tendremos que tratarlo de una manera especial, ya que conocemos una pareja ip:puerto pero la otra va cambiando seg√∫n el destino (el servidor STUN no nos puede ayudar). Haremos uso de la paradoja del cumplea√±os.Suponiendo que la ip que nos devuelve STUN en el lado EDM es correcta (REQ-2 RFC 4787), lo que no conocemos es el puerto. Este ser√° 1 entre 65.535. Si podemos probar 100 puertos/segundo, en el peor caso ser√°n 10 minutos escaneando puertos. Pero podemos hacerlo mejor, si en vez de abrir 1 puerto entre 65.535 en el lado EDM, abrimos 256 el n√∫mero de peticiones aleatorias hasta encontrar una colisi√≥n se reduce mucho.Las mates de esto se explican en la paradoja del cumplea√±os y pueden ser comprobadas con esta calculadora en python. N√∫mero de pruebas Probabilidad de √©xito 174 50% 256 64% 1024 98% 2048 99.9% Si podemos probar 100 puertos/segundo, en el peor de los casos tardaremos 20 segundos en encontrar una colisi√≥n.3. EDM-EDMPodr√≠amos aplicar el mismo truco que en el apartado anterior pero esta vez el espacio de b√∫squeda de colisi√≥n es mucho mayor por lo que con un escaneo de 100 puertos/segundo tardar√≠amos 28 minutos en encontrar una colisi√≥n con un 99.9% de posibilidades. El problema reside en que los routers tienen una memoria finita, por ejemplo el Juniper SRX 300 puede almacenar un m√°ximo de 64.000 sesiones activas. Habr√≠amos consumido todas estas solo para iniciar una conexi√≥n, lo cual ser√≠a un completo desastre.Debemos abandonar esta idea de probar y obtener la colisi√≥n por fuerza bruta. Si queremos establecer una conexi√≥n EDM-EDM podemos explorar t√©cnicas m√°s sofisticadas como analizar el patr√≥n que sigue la NAT para intentar adivinar qu√© traducci√≥n de direcci√≥n va a realizar y as√≠ conseguir la colisi√≥n.Generalmente, el no poder establecer una conexi√≥n EDM-EDM no es un problema porque las NAT de los routers de casa suelen ser EIM y quiz√°s los de empresa sean EDM, por lo que los escenarios home-to-home, home-to-office y home-to-cloud est√°n a salvo.Negociar varias NATs¬øQu√© pasa si est√°s tras varias NATs? Este es mi caso puesto que estoy tras CG-NAT.Realmente, da igual, cada capa de NAT har√° su propia traducci√≥n y todo funcionar√° correctamente.Implementaci√≥nTodo esto lo he implementado en una librer√≠a de Python llamada PyHolePuncher, para que a partir de ella se puedan establecer t√∫neles UDP entre dos dispositivos que est√©n tras una NAT.En el apartado ejemplos encontramos c√≥mo utilizar la librer√≠a para crear un chat P2P. Primero se crea un usuario y se registra en el servidor de se√±alizaci√≥n, en este caso en Rendezvous. Cuando ambos peers est√©n registrados pueden unirse mediante un ‚ÄúChat room‚Äù. Con la opci√≥n ‚ÄúChat to a peer‚Äù se crea el t√∫nel UDP entre los dispositivos que permite intercambiar mensajes.Actualmente soporta los siguientes casos: EIM-EIM EIM-EDM EDM-EDMServidor de se√±alizaci√≥nPara este proyecto he creado un servidor de se√±alizaci√≥n de ejemplo, donde los peers pueden unirse a salas y compartir la informaci√≥n necesaria para establecer la conexi√≥n directa.Rendezvous se trata de un servicio REST simple, cuyos m√©todos est√°n explicados en la documentaci√≥n de Swagger que provee. Una vez los distintos peers est√©n registrados e intercambien la informaci√≥n, podemos pasar al UDP Hole Punching.Leer m√°sPara escribir este post me he inspirado en el blog de Tailscale, muy recomendado pues describe con precisi√≥n el fundamento tecnol√≥gico tras su producto, algo que sirve para aprender mucho sobre el tema. Si se quiere seguir profundizando: How NAT Traversal works How Tailscale works" }, { "title": "Arithmetic Coding - Optimizaci√≥n del algoritmo", "url": "/posts/Arithmetic-Coding-optimization/", "categories": "Algorithm, Coding", "tags": "coding, arithmetic, optimizar, algorithm", "date": "2023-09-14 14:00:00 +0000", "snippet": "Este post es la continuaci√≥n de Arithmetic Coding - Qu√© es y primera implementaci√≥n, que te recomiendo que leas antes de este.Bueno, al l√≠o. Nos encontramos con un algoritmo que no es viable de ejecutar puesto que conforme vamos codificando s√≠mbolos, los n√∫meros que usamos se van haciendo cada vez m√°s largos (en bits).Para solucinar esto nos vamos a aprovechar de una propiedad de estos n√∫meros, y es que si nos fijamos en la imagen, en el juego de partir en porciones y quedarnos con una, el extremo inferior del intervalo que vamos manteniendo (en verde) o crece o se queda igual, nunca decrece. Lo mismo pasa con el extremo superior, siempre decrece o queda igual, nunca crece.Traducci√≥n a bits¬øC√≥mo afecta esto a las variables que usamos en la implementaci√≥n? Primero tenemos que saber c√≥mo vamos a representar estos n√∫meros. Hay dos posibilidades: Punto flotante: se compone de una mantisa (bits de precisi√≥n) y un exponente. Esto te permite representar n√∫meros muy peque√±os o muy grandes con unos pocos d√≠gitos de precisi√≥n. En nuestro caso el extremo superior e inferior van a ser cada vez m√°s cercanos por lo que la distancia entre estos no se podr√° representar usando la precisi√≥n que permite el punto flotante. Punto fijo: establecemos una convenci√≥n del n√∫mero de bits que usamos para la parte entera y decimal. En nuestro caso como los n√∫meros estar√°n dentro de [0,1) tan solo necesitamos parte decimal. Vamos a usar una variable unsigned y la tratamos seg√∫n esta convenci√≥n.Implementaci√≥n ingenuaUna vez sabemos como representar estos n√∫meros, elegimos la longitud en bits que tendr√°n y ejecutamos el algoritmo. Aqu√≠ es cuando aparece el problema anteriormente planteado, conforme vamos codificando s√≠mbolos necesitamos m√°s bits = m√°s tiempo de c√°lculo en la pr√≥xima operaci√≥n matem√°tica.Implementaci√≥n optimizada El extremo inferior siempre crece El extremo superior siempre decreceSi lo vemos en binario ser√≠a tal que as√≠: El 0.25 representado con 4 bits es (0100). Si este es nuestro extremo inferior, solo va a crecer, por lo que si llega a 0.5 (1000), el primer bit pasar√° a ser 1, y as√≠ ser√° siempre. Por lo tanto podremos descartarlo y llevar la cuenta de bits descartados. Con el extremo inferior pasa lo mismo, una vez el primer bit pasa a ser 0 siempre lo ser√°.Adem√°s, sabemos que el extremo superior siempre va a ser mayor que el inferior, por lo que una vez que el primer bit del inferior llega a 1 el del superior tambi√©n queda fijado. De la misma manera ocurre en el otro sentido. Esto permite ir descartando bits seg√∫n vamos pudiendo para as√≠ realizar operaciones matem√°ticas con n√∫meros infinitamente largos pero solo usando unos pocos de sus bits. Estos bits ser√°n los que iremos emitiendo ya que forman el n√∫mero que representa el mensaje codificado.Mola ¬øeh?, esto es lo que hace que hoy en d√≠a se pueda usar este tipo de algoritmos ya que acelera much√≠simo el procesado.Otras optimizaciones √Årbol binario indexado:Por la naturaleza del algoritmo, vamos a realizar muchas consultas al vector de probabilidades que nos facilita el modelo. Siempre necesitamos la probabilidad de s√≠mbolo y d√≥nde se encuentra dentro de las porciones del rango (representadas arriba en verde). A parte, debemos poder actualizar el modelo. Por ello, en lugar de almacenar estas probabilidades en un array lo haremos en un √Årbol binario indexado, que nos permite realizar estas operaciones en O(log n).Otros problemas P√©rdida de precisi√≥n:Puede darse que perdamos precisi√≥n cuando el extremo inferior se acerca a 0.5 por abajo y el extremo superior lo hace por arriba.De esta manera las variables en hexadecimal ser√≠an as√≠: low high 7C99418B 81A60145 7FF8F3E1 8003DFFA 7FFFFC6F 80000DF4 7FFFFFF6 80000001 7FFFFFFF 80000000 Nunca llegamos al 1 inicial en low ni al 0 inicial en high. Para solucionar esto descartaremos el segundo bit m√°s significativo (lo apuntamos en la cuenta de bits descartados) teniendo en cuenta que en alg√∫n momento se cumplir√° la condici√≥n de 0.5. Cuando esto suceda, emitimos el bit correspondiente y los siguientes ser√°n el contrario (tantos como apuntamos en la cuenta).RustEn mi repositorio de github se encuentra la implementaci√≥n en Rust de este algoritmo. El ejemplo comprime ‚ÄúEl Quijote‚Äù usando un modelo simple de frecuencias planas para cada s√≠mbolo, consiguiendo as√≠ pasar de 2.1 MB a 1.1 MB en 0.7 segundos, mientras que con la implementaci√≥n ingenua esto podr√≠a tardar incluso a√±os.Un mayor ratio de compresi√≥n se puede lograr si usamos modelos como PPM o cadenas de Markov, los cuales dan para otro post.Detalles N√∫mero de s√≠mbolos arbitrario: el ejemplo usa 256 para codificar un archivo leido en bytes Modelo de probabilidades plano Uso de variables unsigned32: operaciones con 32 bits Lenguaje compilado para una mayor velocidadLeer m√°sEste art√≠culo pretende ser conciso y ameno, por lo que hay detalles que pueden quedar en el aire. Para obtener m√°s informaci√≥n sobre el tema recomiendo el art√≠culo de Mark Nelson Data Compression With Arithmetic Coding en el que me he inspirado para hacer este post.Personalmente, esto ha sido un reto que me propuse tras finalizar el trabajo incial. He aprendido a tener en cuenta qu√© coste de c√≥mputo tienen las operaciones, manejo a nivel de bit, maneras diferentes de hacer lo mismo, abstraerme para lograr entender un algoritmo complejo y, de paso, programar en Rust." }, { "title": "Arithmetic Coding - Qu√© es y primera implementaci√≥n", "url": "/posts/Arithmetic-Coding/", "categories": "Algorithm, Coding", "tags": "coding, arithmetic, algorithm", "date": "2023-09-11 17:30:00 +0000", "snippet": "El pasado curso hice un trabajo sobre la codificaci√≥n aritm√©tica y sus ventajas frente a otros tipos de codificaci√≥n, aportando un c√≥digo escrito en Python que mostraba su uso.Antes de nada,¬øQu√© es la Codificaci√≥n Aritm√©tica?La codificaci√≥n aritm√©tica es un m√©todo de compresi√≥n sin p√©rdidas que asigna c√≥digos de longitud variable a los s√≠mbolos en funci√≥n de sus probabilidades de ocurrencia. Los s√≠mbolos m√°s probables tendr√°n c√≥digos cortos, mientras que los s√≠mbolos menos probables se codifican con c√≥digos m√°s largos. A diferencia de otras codificaciones, podremos asignar c√≥digos de longitud no entera para los s√≠mbolos, eliminando de esta manera dicha fuente de ineficiencia que tiene, por ejemplo, Huffman.Con esta t√©cnica codificamos los datos en un solo n√∫mero que estar√° entre el 0 y el 1.Ventajas Puede asignar una longitud de c√≥digo no entera a los s√≠mbolos Adecuado para modelos adaptativosLimitaciones Hay que tener la palabra de bits completa para empezar la decodificaci√≥n Si hay un bit corrupto en la palabra puede cambiar mucho el mensajeEjemploVamos a codificar/decodificar la secuencia B A C A.Codificar Lo primero que tenemos que hacer es crear una tabla (Modelo) con los s√≠mbolos que vamos a usar y sus probabilidades. En este caso tenemos 3 s√≠mbolos: S√≠mbolo Probabilidad Rango B 0.25 [0, 0.25) A 0.5 [0.25, 0.75) C 0.25 [0.75, 1) Dividimos el intervalo [0, 1) seg√∫n las probabilidades de ocurrencia. Como el primer s√≠mbolo es la B, nos quedamos con el intervalo [0, 0.25). Volvemos al paso 2, pero esta vez dividimos el intervalo disponible en lugar del [0, 1).De esta manera, repitiendo para cada s√≠mbolo codificamos la secuencia B A C A. En los intervalos mostrados se encuentran todas las secuencias con el mismo prefijo. Debemos poner un s√≠mbolo de fin o indicar la longitud total del mensaje para saber cuando parar de decodificar.El pseudoc√≥digo queda as√≠: Low = 0 High = 1 Bucle. Para cada s√≠mbolo. Rango = high - low High = low + rango * high_range del s√≠mbolo Low = low + rango * low_range del s√≠mbolo DecodificarEl proceso para decodificar es el mismo, gr√°ficamente podemos ver que si nos llega el n√∫mero 0.1640625 podremos identificar que pertenece al rango [0, 0.25), luego a [0.0625, 0.1875), y as√≠ hasta llegar al s√≠mbolo EOF o longitud requerida.ModeloPara codificar/decodificar necesitamos un modelo. Cuanto mejor represente a los datos m√°s nos estaremos acercando al l√≠mite de compresi√≥n enunciado en el Primer Teorema de Shannon en 1934.Existen infinidad de modelos que representen la probabilidad de s√≠mbolo: Modelo simple: tabla de frecuencias est√°tica como la usada en el ejemplo anterior Modelo adaptativo: tabla de frecuencias que var√≠a. Iniciamos con frecuencias equiprobables y las vamos variando seg√∫n van apareciendo los s√≠mbolos Modelo PPM: la frecuencia de los s√≠mbolos depende de los K s√≠mbolos anteriores Modelo de aprendizaje autom√°tico etc√©teraPrimera implementaci√≥nPara el trabajo de clase implement√© una versi√≥n b√°sica (e ineficiente) del algoritmo, pero que demostraba todo lo anterior. Teniendo en cuenta que usar variables de punto flotante nos limitar√≠a los c√°lculos al tama√±o de la mantisa, us√© una librer√≠a de Python llamada ‚Äúdecimal‚Äù, que permite usar aritm√©tica de punto fijo con el n√∫mero de bits que queramos.El problema de esto reside en que cada vez que actualizamos el n√∫mero que representa el mensaje a codificar, necesitamos m√°s bits. M√°s bits = m√°s tiempo de computaci√≥n en la siguiente operaci√≥n matem√°tica. Por lo tanto, conforme aumentamos la longitud del mensaje el tiempo de procesamiento aumenta exponencialmente.Soluci√≥n¬øC√≥mo solucion√© esto? Pues eso es tema para el pr√≥ximo post. Arithmetic Coding - Optimizaci√≥n del algoritmo" }, { "title": "C√≥mo consegu√≠ 400 usuarios para esta Web de F1", "url": "/posts/Como-consegui-400-usuarios/", "categories": "Web, F1", "tags": "web, f1, twitter, viral", "date": "2023-02-22 16:30:00 +0000", "snippet": "Esta es la historia de c√≥mo llegamos a tener una web de F√≥rmula 1 con m√°s de 400 usuarios hecha en tan solo 7 d√≠as.El comienzoDurante el auge del fen√≥meno EL PLAN en Twitter, all√° por Febrero de 2022, @manueljerez7_ y yo tuvimos la idea de crear una web a modo de porra para un conjunto reducido de amigos.Aprovechamos que √©l ten√≠a un grupo con otros usuarios de Twitter F1 que se reun√≠an usando la herramienta Twitter Spaces para comentarles la idea. Les encant√≥, por lo que decidimos poner un Tweet para ver si a m√°s gente le gustaba. Se viraliz√≥.CHAVALES este a√±o se viene a TwF1 un super UPGRADE:UNA WEB SENCILLA para hacer LA PORRA DE LA CARRERATe registras con tu usuario de Twitter, metes resultados y ves la clasificaci√≥n general de puntosPronto os dir√© m√°s üëÄüëÄüëÄSe agradece difusi√≥n para llegar a m√°s gente üôè&amp;mdash; Manu üòâ (@manueljerez7_) February 11, 2022700 Likes, 130 RT, 90.000 Visualizaciones‚Ä¶ Fue una idea muy bien recibida por la comunidad, as√≠ que nos pusimos manos a la obra ya que quedaban a penas 2 semanas para el comienzo de temporada y ten√≠a que estar todo listo, funcionando y probado para el primer Gran Premio.C√≥mo nos organizamosAmbos est√°bamos cursando el grado de Ingenier√≠a Telecomunicaciones en la Universidad de Sevilla, por lo que ten√≠amos que organizar el poco tiempo sobrante que ten√≠amos para llevar a cabo este proyecto. gantt dateFormat YYYY-MM-DD axisFormat %d title La Porra de Twitter F1 section Reglas Lluvia de ideas :a, 2022-02-09, 2d Formalizaci√≥n :b, after a, 2d section Investigaci√≥n BBDD :c, 2022-02-09, 2d Despliegue :e, 2022-02-10, 2d section Implementaci√≥n Dise√±o :f, 2022-02-10, 2d Inicio de sesi√≥n :d, after f, 2d Juego :g, after f, 3d section Optimizaci√≥n BBDD: h, 2022-02-15, 3d Servidor: i, 2022-02-15, 3dIdeas claveDe la fase de lluvia de ideas sacamos varias claves:- Inicio de sesi√≥n usando API TwitterEs muy importante eliminar las barreras de entrada que pueda tener un usuario. Puesto que nuestra publicidad era Twitter, el registro en nuestra web se har√° mediante su API. El usuario √∫nicamente tendr√° que dar acceso a su nombre de cuenta en Twitter y su @ ser√° su usuario en la web.Desde mi punto de vista, esto fue un completo acierto ya que el pulsar un bot√≥n de inicio de sesi√≥n con Twitter hace que el registro se vuelva autom√°tico y nada pesado.- Bot√≥n compartir en Twitter estilo WordleWordle se hab√≠a viralizado ya que la gente pod√≠a hacer el reto diario y compartir su famoso c√≥digo de colores en Twitter, por lo que nosotros inventamos el nuestro propio.Esto nos ayuda a llegar a un mayor p√∫blico. Entrando en el hastag #LaPorraDeTwF1 se pueden comprobar los Tweets de los usuarios.Mis resultados de #LaPorraDeTwF1 para Bahrainüü© üü•üü® üü®üü• üü•üü• üü•üü• üü•&amp;mdash; Enrique S√°nchez (@enriqueesanchz) March 20, 2022- ReglasLas reglas se debatieron durante los primeros d√≠as para su posterior formalizaci√≥n. B√°sicamente consiste en colocar a los pilotos que creas que van a quedar los 10 primeros y seg√∫n los resultados se te asigna una puntuaci√≥n dependiendo de lo cerca que hayas estado de acertar.Investigaci√≥nEsta era una parte importante para decidir qu√© servicios √≠bamos a usar tanto para la Base de Datos como para d√≥nde desplegar la Web, siempre intentando minimizar costes, ya que √©ramos estudiantes sin fuente de ingresos.- BBDDPara la Base de Datos ten√≠amos las posibilidades de Google Cloud SQL, Firebase, Azure SQL, AWS SQL Server, etc. Terminamos decant√°ndonos por Azure ya que por $5 ten√≠amos 2Gb de almacenamiento, coste√°ndolo durante la temporada de F√≥rmula 1 con el plan para estudiantes.- ServidorOtra parte vital es d√≥nde desplegar la Web. Entre las diferentes opciones estaban de nuevo las plataformas de Google, Azure, AWS, etc. Al final elegimos Heroku con su plan gratuito ya que ten√≠amos experiencia previa, Python y Flask. Cabe recalcar que ten√≠amos algo de miedo por la viralizaci√≥n del Tweet y porque el n√∫mero de usuarios que podr√≠amos tener quiz√°s hac√≠a que la web cayese.Implementaci√≥nEn esta parte ideamos c√≥mo iban a ser los diferentes componentes de nuestra arquitectura, sus relaciones y dependencias, etc.Comprende desde la implementaci√≥n del inicio de sesi√≥n con Twitter para la web hasta la implementaci√≥n del las reglas de la Porra en la Aplicaci√≥n Web.Optimizaci√≥nDurante estos d√≠as, estuve investigando sobre c√≥mo optimizar al m√°ximo nuestra web, en qu√© partes pod√≠amos usar cach√© y en cu√°les no, y otras optimizaciones de cara al servidor Web a usar, el n√∫mero de hilos, etc. Est√°bamos preocupados por la viralizaci√≥n en Twitter.Conclusi√≥nSe trata de una App Web sencilla, simple, hecha en tiempo r√©cord, que cumple su funci√≥n: Tener una porra a golpe de click desde Twitter, ideada para la comunidad de Twitter F√≥rmula 1.Terminamos teniendo m√°s de 400 usuarios, muy contentos, aunque sabemos que podr√≠an haber sido m√°s. Esto se debe a que la dificultad de conseguir un Tweet viral creci√≥ para cuando se iba a iniciar la temporada de F1 por lo que aunque con el Tweet del primer anuncio lleg√°semos a 90 mil visualizaciones, los que pusimos en las v√≠speras del primer Gran Premio obtuvieron muchas menos debido a la cantidad de informaci√≥n y tweets que hubo en aquella √©poca.Personalmente, considero todo un √©xito este proyecto, en el cual he aprendido mucho con un ejemplo del mundo real y creo que la clave ha estado en centrarnos en la comodidad del usuario y la compartici√≥n en Twitter de los resultados con el c√≥digo de colores.Leer m√°s An√°lisis de datos de usuarios La Porra de Twitter F1 Diario de Manuel con el proyecto" } ]
